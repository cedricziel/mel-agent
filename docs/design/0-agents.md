# AI Agents SaaS â€“ Design Document

## 1. Purpose & Scope

This document captures the **data model** and the underlying **design rationale** for the first version (_v0_) of a SaaS platform that enables customers to compose, configure, and run AIâ€powered agents to automate their daily tasks (eâ€‘mails triage, meeting summaries, social posts, etc.).  
The focus is deliberately limited to **persistenceâ€‘layer concerns**â€”what we store, why we store it, and how the pieces fit together.  API design, UI/UX and runtime architecture are covered in separate documents.

## 2. Problem & User Value

1. **Fragmented workflows** â€“ Knowledge workers juggle multiple tools (eâ€‘mail, Slack, Jira, Notion) and lose time on lowâ€‘leverage, repetitive tasks.
2. **AI capabilities are opaque** â€“ Nonâ€‘technical users want AI assistance but have no easy way to express multiâ€‘step logic, orchestrate calls to different LLMs/APIs, or manage retries & monitoring.

Our platform provides:

* **Selfâ€‘serve agent builder** â€“ Assemble skills (â€œdraft eâ€‘mail replyâ€, â€œsummarise Slack threadâ€) into reusable agents without code.
* **Oneâ€‘click deployment & scheduling** â€“ Run an agent onâ€‘demand, on a schedule, or on incoming webhooks.
* **Auditability & control** â€“ Inspect every execution, override outputs, pause/resume agents.

> **Outcome**: Users reclaim time, reduce contextâ€‘switching, and gain confidence that automations behave as intended.

## 3. Core Concepts

| Concept      | Description |
|--------------|-------------|
| **User**     | Account owner (individual or organisation) who builds and owns agents. |
| **Agent**    | A named, versioned blueprint describing a graph of **Skills** plus runtime settings. |
| **Skill**    | Atomic capability (call LLM, fetch data, transform text). Skills can be reused across agents. |
| **Trigger**  | Event that starts an agent run (schedule, webhook, manual). |
| **Run**      | Concrete execution of an agent; stores inputs, outputs, status, logs. |
| **Credential** | OAuth tokens, API keys, etc., stored encrypted and scoped per user/agent. |
| **Integration** | Thirdâ€‘party system that a skill can interact with (Gmail, Slack, internal API). |
| **Usage Meter** | Aggregated tokens / API calls used for billing. |

### Creation Interfaces (human & machine)

* **Visual Builder** â€“ Dragâ€‘andâ€‘drop UI where endâ€‘users compose skills into a directed acyclic graph (DAG).  
* **Public API / SDK** â€“ Programmatic surface (REST + JSONSchema or GraphQL) that lets powerâ€‘users or other agents generate/update the very same `graph` payload stored in `agent_versions`.  
  â€¢ Enables metaâ€‘workflows such as â€œan onboarding agent that provisions custom agents for each new employeeâ€.  
  â€¢ Ensures complete parity: anything doable in the UI must be doable through the API and viceâ€‘versa.  
* **Infrastructureâ€‘asâ€‘Code** â€“ For larger customers we can expose a Terraform provider / YAML spec that serialises exactly the same API operations, enabling GitOps flows.

The **data model is intentionally UIâ€‘agnostic**: all behaviour is encoded in JSONB (graph + skill spec) so that agents created by machines are not secondâ€‘class citizens.


## 4. Data Model (Relational firstâ€‘cut)

We target **PostgreSQL 15** because:

* Rich JSONB: flexible storage for skill graphs & LLM params that evolve quickly.
* ACID/transactions: required for idempotent runs & billing.
* Mature extensions (Rowâ€‘Level Security, pgcrypto) for multiâ€‘tenant separation.

Entity diagrams are shown below in text form (PKðŸ”‘, FKðŸ”—).

### 4.1 Tables

1. `users`
```
id ðŸ”‘ UUID             -- primary key, generated by backend
email UNIQUE NOT NULL
name  TEXT
plan  TEXT             -- free, pro, enterprise
created_at TIMESTAMPTZ DEFAULT now()
```

2. `agents`
```
id ðŸ”‘ UUID
user_id ðŸ”— UUID REFERENCES users(id) ON DELETE CASCADE
name      TEXT NOT NULL
description TEXT
is_active   BOOLEAN DEFAULT TRUE
latest_version_id ðŸ”— UUID REFERENCES agent_versions(id)
created_at TIMESTAMPTZ DEFAULT now()
```

3. `agent_versions`
```
id ðŸ”‘ UUID
agent_id ðŸ”— UUID REFERENCES agents(id) ON DELETE CASCADE
semantic_version  TEXT -- e.g. 1.0.3
graph   JSONB NOT NULL  -- DAG of skills with connection info
default_params JSONB    -- temperature, model, etc.
created_at TIMESTAMPTZ DEFAULT now()
```

4. `skills`
```
id ðŸ”‘ UUID
name TEXT NOT NULL
type TEXT CHECK (type IN ('llm', 'http_request', 'code', 'transform', 'builtin'))
spec JSONB NOT NULL        -- schema varies by type
owner_user_id ðŸ”— UUID NULL  -- null = platformâ€‘provided skill
created_at TIMESTAMPTZ DEFAULT now()
```

5. `triggers`
```
id ðŸ”‘ UUID
agent_id ðŸ”— UUID REFERENCES agents(id) ON DELETE CASCADE
kind TEXT CHECK (kind IN ('schedule', 'webhook', 'manual'))
schedule_cron TEXT NULL  -- for kind='schedule'
webhook_secret TEXT NULL -- for kind='webhook'
is_enabled BOOLEAN DEFAULT TRUE
created_at TIMESTAMPTZ DEFAULT now()
```

6. `runs`
```
id ðŸ”‘ UUID
agent_version_id ðŸ”— UUID REFERENCES agent_versions(id)
trigger_id ðŸ”— UUID NULL  -- may be manual run without trigger
status TEXT CHECK (status IN ('queued', 'running', 'succeeded', 'failed', 'canceled'))
input  JSONB
output JSONB
started_at TIMESTAMPTZ
finished_at TIMESTAMPTZ
error TEXT
usage JSONB             -- token counts, API calls
```

7. `run_steps` (optional granular logging)
```
id ðŸ”‘ UUID
run_id ðŸ”— UUID REFERENCES runs(id) ON DELETE CASCADE
skill_id ðŸ”— UUID REFERENCES skills(id)
idx INTEGER            -- execution order
status TEXT
input  JSONB
output JSONB
started_at TIMESTAMPTZ
finished_at TIMESTAMPTZ
error TEXT
usage JSONB
```

8. `credentials`
```
id ðŸ”‘ UUID
user_id ðŸ”— UUID REFERENCES users(id) ON DELETE CASCADE
integration_id ðŸ”— UUID REFERENCES integrations(id)
name TEXT NOT NULL                 -- â€œPersonal Gmailâ€
secret JSONB ENCRYPTED WITH pgcrypto
created_at TIMESTAMPTZ DEFAULT now()
```

9. `integrations`
```
id ðŸ”‘ UUID
name TEXT UNIQUE NOT NULL        -- â€œgmailâ€, â€œslackâ€
auth_type TEXT CHECK (auth_type IN ('oauth2', 'api_key', 'none'))
spec JSONB                      -- endpoint templates, scopes
```

10. `usage_ledger`
```
id ðŸ”‘ UUID
user_id ðŸ”— UUID
run_id ðŸ”— UUID
tokens_prompt INTEGER
tokens_completion INTEGER
third_party_cost_cents INTEGER
timestamp TIMESTAMPTZ DEFAULT now()
```

### 4.2 Key Design Decisions

1. **Versioning via `agent_versions`**  
   *Immutable designs* guarantee previous runs stay reproducible even after the user edits the agent.

2. **JSONB for `graph` and `spec`**  
   The graph of skills is naturally hierarchical and evolves quickly (parallel branches, loops); storing it as JSONB avoids frequent migrations while still supporting GINâ€‘indexed queries (e.g. â€œfind agents that reference skill Xâ€).

3. **`run_steps` table optional**  
   By default only the highâ€‘level run row is kept; enterprise plans can optâ€‘in for detailed lineage for auditing.

4. **Row Level Security (RLS)**  
   All tenant isolation is enforced at the DB level so that misâ€‘configured backend code cannot leak data across tenants.

5. **Encrypted `credentials.secret`**  
   We use `pgcrypto`â€™s `pgp_sym_encrypt`, storing only cipherâ€‘text. Key is injected at runtime via KMS.


## 5. Typical Access Patterns & Indexes

1. List active agents for a user  
   `SELECT * FROM agents WHERE user_id = $1 AND is_active = TRUE ORDER BY created_at DESC;`  
   âžœ  index on `(user_id, is_active)`.

2. Fetch latest version when executing  
   `SELECT * FROM agent_versions WHERE id = agents.latest_version_id;`  
   âžœ  direct by PK.

3. Analytics on token usage  
   `SELECT date_trunc('day', timestamp), SUM(tokens_prompt+tokens_completion) FROM usage_ledger WHERE user_id=$1 GROUP BY 1;`


## 6. Evolution Strategy

* **Minor schema changes** â€“ additive columns, default values. Handled via zeroâ€‘downtime migrations.
* **Major graph changes** â€“ keep backward compatibility by bumping `semantic_version` and writing data migration inside the application.


## 7. Nonâ€‘functional Requirements

| Area          | Requirement |
|---------------|-------------|
| Scalability   | 50k daily active users, P99 run start â‰¤ 1Â s |
| Availability  | 99.9Â % for run execution & logs |
| Compliance    | SOC2â€‘TypeÂ II by yearâ€‘1; GDPR DSAR export via `runs`+`run_steps` dumps |
| Security      | Encryption at rest & in transit; regular penâ€‘testing; leastâ€‘privilege RBAC |


## 8. Open Questions

1. Do we allow nested agents (agent calls another agent)? If yes, we may need a `sub_run_id` FK.
2. Longâ€‘running jobs (e.g. >15Â min) might outgrow sync execution â€“ consider `run_chunks` table.
3. Multiâ€‘organisation accounts with shared agent libraries.
4. Provenance tracking when one agent programmatically spawns or edits another: do we store `parent_run_id` on `agent_versions`?


---
_Last updated: 2025â€‘04â€‘17_
