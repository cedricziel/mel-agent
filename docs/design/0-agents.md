# AI Agents SaaS – Design Document

## 1. Purpose & Scope

This document captures the **data model** and the underlying **design rationale** for the first version (_v0_) of a SaaS platform that enables customers to compose, configure, and run AI‐powered agents to automate their daily tasks (e‑mails triage, meeting summaries, social posts, etc.).  
The focus is deliberately limited to **persistence‑layer concerns**—what we store, why we store it, and how the pieces fit together.  API design, UI/UX and runtime architecture are covered in separate documents.

## 2. Problem & User Value

1. **Fragmented workflows** – Knowledge workers juggle multiple tools (e‑mail, Slack, Jira, Notion) and lose time on low‑leverage, repetitive tasks.
2. **AI capabilities are opaque** – Non‑technical users want AI assistance but have no easy way to express multi‑step logic, orchestrate calls to different LLMs/APIs, or manage retries & monitoring.

Our platform provides:

* **Self‑serve agent builder** – Assemble skills (“draft e‑mail reply”, “summarise Slack thread”) into reusable agents without code.
* **One‑click deployment & scheduling** – Run an agent on‑demand, on a schedule, or on incoming webhooks.
* **Auditability & control** – Inspect every execution, override outputs, pause/resume agents.

> **Outcome**: Users reclaim time, reduce context‑switching, and gain confidence that automations behave as intended.

## 3. Core Concepts

| Concept      | Description |
|--------------|-------------|
| **User**     | Account owner (individual or organisation) who builds and owns agents. |
| **Agent**    | A named, versioned blueprint describing a graph of **Skills** plus runtime settings. |
| **Skill**    | Atomic capability (call LLM, fetch data, transform text). Skills can be reused across agents. |
| **Trigger**  | Event that starts an agent run (schedule, webhook, manual). |
| **Run**      | Concrete execution of an agent; stores inputs, outputs, status, logs. |
| **Credential** | OAuth tokens, API keys, etc., stored encrypted and scoped per user/agent. |
| **Integration** | Third‑party system that a skill can interact with (Gmail, Slack, internal API). |
| **Usage Meter** | Aggregated tokens / API calls used for billing. |

### Creation Interfaces (human & machine)

* **Visual Builder** – Drag‑and‑drop UI where end‑users compose skills into a directed acyclic graph (DAG).  
* **Public API / SDK** – Programmatic surface (REST + JSONSchema or GraphQL) that lets power‑users or other agents generate/update the very same `graph` payload stored in `agent_versions`.  
  • Enables meta‑workflows such as “an onboarding agent that provisions custom agents for each new employee”.  
  • Ensures complete parity: anything doable in the UI must be doable through the API and vice‑versa.  
* **Infrastructure‑as‑Code** – For larger customers we can expose a Terraform provider / YAML spec that serialises exactly the same API operations, enabling GitOps flows.

The **data model is intentionally UI‑agnostic**: all behaviour is encoded in JSONB (graph + skill spec) so that agents created by machines are not second‑class citizens.


## 4. Data Model (Relational first‑cut)

We target **PostgreSQL 15** because:

* Rich JSONB: flexible storage for skill graphs & LLM params that evolve quickly.
* ACID/transactions: required for idempotent runs & billing.
* Mature extensions (Row‑Level Security, pgcrypto) for multi‑tenant separation.

Entity diagrams are shown below in text form (PK🔑, FK🔗).

### 4.1 Tables

1. `users`
```
id 🔑 UUID             -- primary key, generated by backend
email UNIQUE NOT NULL
name  TEXT
plan  TEXT             -- free, pro, enterprise
created_at TIMESTAMPTZ DEFAULT now()
```

2. `agents`
```
id 🔑 UUID
user_id 🔗 UUID REFERENCES users(id) ON DELETE CASCADE
name      TEXT NOT NULL
description TEXT
is_active   BOOLEAN DEFAULT TRUE
latest_version_id 🔗 UUID REFERENCES agent_versions(id)
created_at TIMESTAMPTZ DEFAULT now()
```

3. `agent_versions`
```
id 🔑 UUID
agent_id 🔗 UUID REFERENCES agents(id) ON DELETE CASCADE
semantic_version  TEXT -- e.g. 1.0.3
graph   JSONB NOT NULL  -- DAG of skills with connection info
default_params JSONB    -- temperature, model, etc.
created_at TIMESTAMPTZ DEFAULT now()
```

4. `skills`
```
id 🔑 UUID
name TEXT NOT NULL
type TEXT CHECK (type IN ('llm', 'http_request', 'code', 'transform', 'builtin'))
spec JSONB NOT NULL        -- schema varies by type
owner_user_id 🔗 UUID NULL  -- null = platform‑provided skill
created_at TIMESTAMPTZ DEFAULT now()
```

5. `triggers`
```
id 🔑 UUID
agent_id 🔗 UUID REFERENCES agents(id) ON DELETE CASCADE
kind TEXT CHECK (kind IN ('schedule', 'webhook', 'manual'))
schedule_cron TEXT NULL  -- for kind='schedule'
webhook_secret TEXT NULL -- for kind='webhook'
is_enabled BOOLEAN DEFAULT TRUE
created_at TIMESTAMPTZ DEFAULT now()
```

6. `runs`
```
id 🔑 UUID
agent_version_id 🔗 UUID REFERENCES agent_versions(id)
trigger_id 🔗 UUID NULL  -- may be manual run without trigger
status TEXT CHECK (status IN ('queued', 'running', 'succeeded', 'failed', 'canceled'))
input  JSONB
output JSONB
started_at TIMESTAMPTZ
finished_at TIMESTAMPTZ
error TEXT
usage JSONB             -- token counts, API calls
```

7. `run_steps` (optional granular logging)
```
id 🔑 UUID
run_id 🔗 UUID REFERENCES runs(id) ON DELETE CASCADE
skill_id 🔗 UUID REFERENCES skills(id)
idx INTEGER            -- execution order
status TEXT
input  JSONB
output JSONB
started_at TIMESTAMPTZ
finished_at TIMESTAMPTZ
error TEXT
usage JSONB
```

8. `credentials`
```
id 🔑 UUID
user_id 🔗 UUID REFERENCES users(id) ON DELETE CASCADE
integration_id 🔗 UUID REFERENCES integrations(id)
name TEXT NOT NULL                 -- “Personal Gmail”
secret JSONB ENCRYPTED WITH pgcrypto
created_at TIMESTAMPTZ DEFAULT now()
```

9. `integrations`
```
id 🔑 UUID
name TEXT UNIQUE NOT NULL        -- “gmail”, “slack”
auth_type TEXT CHECK (auth_type IN ('oauth2', 'api_key', 'none'))
spec JSONB                      -- endpoint templates, scopes
```

10. `usage_ledger`
```
id 🔑 UUID
user_id 🔗 UUID
run_id 🔗 UUID
tokens_prompt INTEGER
tokens_completion INTEGER
third_party_cost_cents INTEGER
timestamp TIMESTAMPTZ DEFAULT now()
```

### 4.2 Key Design Decisions

1. **Versioning via `agent_versions`**  
   *Immutable designs* guarantee previous runs stay reproducible even after the user edits the agent.

2. **JSONB for `graph` and `spec`**  
   The graph of skills is naturally hierarchical and evolves quickly (parallel branches, loops); storing it as JSONB avoids frequent migrations while still supporting GIN‑indexed queries (e.g. “find agents that reference skill X”).

3. **`run_steps` table optional**  
   By default only the high‑level run row is kept; enterprise plans can opt‑in for detailed lineage for auditing.

4. **Row Level Security (RLS)**  
   All tenant isolation is enforced at the DB level so that mis‑configured backend code cannot leak data across tenants.

5. **Encrypted `credentials.secret`**  
   We use `pgcrypto`’s `pgp_sym_encrypt`, storing only cipher‑text. Key is injected at runtime via KMS.


## 5. Typical Access Patterns & Indexes

1. List active agents for a user  
   `SELECT * FROM agents WHERE user_id = $1 AND is_active = TRUE ORDER BY created_at DESC;`  
   ➜  index on `(user_id, is_active)`.

2. Fetch latest version when executing  
   `SELECT * FROM agent_versions WHERE id = agents.latest_version_id;`  
   ➜  direct by PK.

3. Analytics on token usage  
   `SELECT date_trunc('day', timestamp), SUM(tokens_prompt+tokens_completion) FROM usage_ledger WHERE user_id=$1 GROUP BY 1;`


## 6. Evolution Strategy

* **Minor schema changes** – additive columns, default values. Handled via zero‑downtime migrations.
* **Major graph changes** – keep backward compatibility by bumping `semantic_version` and writing data migration inside the application.


## 7. Non‑functional Requirements

| Area          | Requirement |
|---------------|-------------|
| Scalability   | 50k daily active users, P99 run start ≤ 1 s |
| Availability  | 99.9 % for run execution & logs |
| Compliance    | SOC2‑Type II by year‑1; GDPR DSAR export via `runs`+`run_steps` dumps |
| Security      | Encryption at rest & in transit; regular pen‑testing; least‑privilege RBAC |


## 8. Open Questions

1. Do we allow nested agents (agent calls another agent)? If yes, we may need a `sub_run_id` FK.
2. Long‑running jobs (e.g. >15 min) might outgrow sync execution – consider `run_chunks` table.
3. Multi‑organisation accounts with shared agent libraries.
4. Provenance tracking when one agent programmatically spawns or edits another: do we store `parent_run_id` on `agent_versions`?


---
_Last updated: 2025‑04‑17_
